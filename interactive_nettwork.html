<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>ActEarly Child Health Map</title>

  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      background: #f8f8f8;
    }

    .page {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }

    h1 {
      margin-top: 0;
      font-weight: 600;
    }

    .graph-frame {
      border: 2px solid #ccc;
      border-radius: 8px;
      background: #fff;
      height: 800px;          /* adjust if you want bigger/smaller */
      overflow: hidden;
      position: relative;
      margin: 20px 0;
    }

    #container {
      width: 100%;
      height: 100%;
    }

    .footer-text {
      font-size: 0.9em;
      color: #555;
      margin-top: 10px;
    }
  </style>

  <!-- Import maps for Sigma & Graphology -->
  <script type="importmap">
    {
      "imports": {
        "sigma": "https://cdnjs.cloudflare.com/ajax/libs/sigma.js/3.0.0/sigma.min.js",
        "graphology": "https://cdn.jsdelivr.net/npm/graphology@0.26.0/dist/graphology.umd.min.js",
        "graphologyLibrary": "https://cdn.jsdelivr.net/npm/graphology-library/dist/graphology-library.min.js"
      }
    }
  </script>
</head>

<body>
<div class="page">

  <h1>ActEarly Child Health Map</h1>

  <p>
  The network shows the number of ActEarly projects (by node size - larger node means more ActEarly projects operating in this part of the network), that were opperating in that part of the Child Health System (as defined by <a href="https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0245577">Jessiman et. al 2021</a>).
  
  <p>
    This interactive visualisation uses <strong>Sigma.js</strong> and
    <strong>ForceAtlas2</strong> layout.  
    Hover over any node to highlight its immediate neighbours, zoom with the mouse wheel, left click to drag the graph position.
  </p>

  <div class="graph-frame">
    <div id="container"></div>
  </div>

  <p class="footer-text">
    Data source: <code>graph.json</code>.  
    Layout computed with ForceAtlas2.  
    Node size proportional to <code>size_nolog</code>.
  </p>

</div>

  <!-- Import map for Sigma, Graphology, and Graphology Library -->
  <script type="importmap">
    {
      "imports": {
        "sigma": "https://cdnjs.cloudflare.com/ajax/libs/sigma.js/3.0.0/sigma.min.js",
        "graphology": "https://cdn.jsdelivr.net/npm/graphology@0.26.0/dist/graphology.umd.min.js",
        "graphologyLibrary": "https://cdn.jsdelivr.net/npm/graphology-library/dist/graphology-library.min.js"
      }
    }
  </script>
</head>
<body>
<div id="container"></div>

<script type="module">
  // Load libraries (Sigma exports aren’t used directly here; it exposes global Sigma)
  import * as sigma from 'sigma';
  import 'graphology';          // UMD: attaches `graphology` to window
  import 'graphologyLibrary';   // UMD: attaches `graphologyLibrary` to window

  const Graph = graphology.Graph;

  fetch('graph.json')
    .then(r => r.json())
    .then(data => {
      const graph = new Graph({ type: 'undirected', allowSelfLoops: false });

      // --- 1. Figure out size_nolog range for scaling ---
      let minSize = Infinity;
      let maxSize = -Infinity;

      for (const n of data.nodes) {
        const s = typeof n.size_nolog === 'number' ? n.size_nolog : 1;
        if (s < minSize) minSize = s;
        if (s > maxSize) maxSize = s;
      }
      if (!isFinite(minSize)) minSize = 1;
      if (!isFinite(maxSize)) maxSize = minSize;

      function mapSize(value, inMin, inMax, outMin, outMax) {
        if (inMax === inMin) return (outMin + outMax) / 2;
        const t = (value - inMin) / (inMax - inMin);
        return outMin + t * (outMax - outMin);
      }

      // --- 2. Add nodes ---
      for (const n of data.nodes) {
        const id = String(n.id);
        const label = n.label || n.name || id;
        const raw = typeof n.size_nolog === 'number' ? n.size_nolog : 1;
        const sizePx = mapSize(raw, minSize, maxSize, 4, 18);

        graph.addNode(id, {
          label,
          x: Math.random(),
          y: Math.random(),
          size: sizePx,
          color: 'orange'
        });
      }

      // --- 3. Add edges (FIXED: use addEdge(source, target, attrs)) ---
      for (const e of data.edges) {
        const source = String(e.source);
        const target = String(e.target);

        if (!graph.hasNode(source) || !graph.hasNode(target)) continue;
        if (graph.hasEdge(source, target)) continue;  // avoid duplicates if any

        graph.addEdge(source, target, {
          size: 1,
          color: '#bbbbbb'
        });
      }

      // --- 4. ForceAtlas2 layout ---
      const settings = graphologyLibrary.layoutForceAtlas2.inferSettings(graph);
      graphologyLibrary.layoutForceAtlas2.assign(graph, {
        iterations: 200,   // increase for smoother layout if performance is fine
        settings
      });

      // --- 5. Create Sigma renderer ---
      const container = document.getElementById('container');
      const renderer = new Sigma(graph, container, {
          renderEdgeLabels: false,
          defaultNodeColor: 'orange',

          // Show labels aggressively
          labelDensity: 1,               // 0–1, higher = more labels
          labelGridCellSize: 20,         // smaller cells = more labels can fit
          labelRenderedSizeThreshold: 0, // always render labels, even when zoomed out

          // Optional: slightly smaller text if things feel cluttered
          labelSize: 10
        });

      // --- 6. Hover highlighting: keep node + neighbors, fade rest ---
      const state = {
        hoveredNode: null,
        hoveredNeighbors: new Set()
      };

      renderer.setSetting('nodeReducer', (node, data) => {
        const res = { ...data };

        if (state.hoveredNode === null) {
          return res; // no hover → normal view
        }

        const isHovered = node === state.hoveredNode;
        const isNeighbor = state.hoveredNeighbors.has(node);

        if (!isHovered && !isNeighbor) {
          // Fade non-neighbors
          res.color = '#dddddd';
          res.label = '';   // hide labels for faded nodes
          res.zIndex = 0;
        } else {
          // Emphasize hovered node and neighbors
          res.color = 'orange';
          res.zIndex = 1;
        }

        return res;
      });

      renderer.setSetting('edgeReducer', (edge, data) => {
        const res = { ...data };

        if (state.hoveredNode === null) {
          return res;
        }

        const source = graph.source(edge);
        const target = graph.target(edge);
        const keep =
          source === state.hoveredNode ||
          target === state.hoveredNode ||
          (state.hoveredNeighbors.has(source) &&
           state.hoveredNeighbors.has(target));

        if (!keep) {
          res.color = '#eeeeee';
        } else {
          res.color = '#bbbbbb';
        }

        return res;
      });

      renderer.on('enterNode', ({ node }) => {
        state.hoveredNode = node;
        state.hoveredNeighbors = new Set(graph.neighbors(node));
        renderer.refresh();
      });

      renderer.on('leaveNode', () => {
        state.hoveredNode = null;
        state.hoveredNeighbors = new Set();
        renderer.refresh();
      });
    })
    .catch(err => {
      console.error('Error loading graph.json:', err);
    });
</script>
</body>
</html>
